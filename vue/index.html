<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vue基本知识点 | 个人主页</title>
    <meta name="description" content="zouyu的博客">
    <link rel="icon" href="/img/logo.ico">
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    
    <link rel="preload" href="/assets/css/0.styles.91fb4f46.css" as="style"><link rel="preload" href="/assets/js/app.f08b4700.js" as="script"><link rel="preload" href="/assets/js/2.4e7c4cdc.js" as="script"><link rel="preload" href="/assets/js/65.12532cb0.js" as="script"><link rel="prefetch" href="/assets/js/10.29da53b7.js"><link rel="prefetch" href="/assets/js/11.b9e5c0a2.js"><link rel="prefetch" href="/assets/js/12.1b920300.js"><link rel="prefetch" href="/assets/js/13.8f1410d3.js"><link rel="prefetch" href="/assets/js/14.8265c927.js"><link rel="prefetch" href="/assets/js/15.54584ae0.js"><link rel="prefetch" href="/assets/js/16.9fb008c1.js"><link rel="prefetch" href="/assets/js/17.ea99b802.js"><link rel="prefetch" href="/assets/js/18.67058257.js"><link rel="prefetch" href="/assets/js/19.9f19f1d0.js"><link rel="prefetch" href="/assets/js/20.fb58f61e.js"><link rel="prefetch" href="/assets/js/21.5a977c24.js"><link rel="prefetch" href="/assets/js/22.a90d3467.js"><link rel="prefetch" href="/assets/js/23.f6feed05.js"><link rel="prefetch" href="/assets/js/24.9d628d92.js"><link rel="prefetch" href="/assets/js/25.984dcd9d.js"><link rel="prefetch" href="/assets/js/26.aab16960.js"><link rel="prefetch" href="/assets/js/27.5b6a2303.js"><link rel="prefetch" href="/assets/js/28.3ad52353.js"><link rel="prefetch" href="/assets/js/29.79266221.js"><link rel="prefetch" href="/assets/js/3.21a670ed.js"><link rel="prefetch" href="/assets/js/30.9bc50357.js"><link rel="prefetch" href="/assets/js/31.b40f8d50.js"><link rel="prefetch" href="/assets/js/32.c16afd56.js"><link rel="prefetch" href="/assets/js/33.1110315b.js"><link rel="prefetch" href="/assets/js/34.b58a2867.js"><link rel="prefetch" href="/assets/js/35.acd92c77.js"><link rel="prefetch" href="/assets/js/36.ccc923fb.js"><link rel="prefetch" href="/assets/js/37.c7597311.js"><link rel="prefetch" href="/assets/js/38.ca816e2f.js"><link rel="prefetch" href="/assets/js/39.c0df6aa2.js"><link rel="prefetch" href="/assets/js/4.fe69ddff.js"><link rel="prefetch" href="/assets/js/40.3a9fa751.js"><link rel="prefetch" href="/assets/js/41.f3d589b3.js"><link rel="prefetch" href="/assets/js/42.8e2fc2a1.js"><link rel="prefetch" href="/assets/js/43.9c38e667.js"><link rel="prefetch" href="/assets/js/44.ce58c4cf.js"><link rel="prefetch" href="/assets/js/45.486dcf6d.js"><link rel="prefetch" href="/assets/js/46.553abdb3.js"><link rel="prefetch" href="/assets/js/47.e36b0f26.js"><link rel="prefetch" href="/assets/js/48.5167f14e.js"><link rel="prefetch" href="/assets/js/49.904c4996.js"><link rel="prefetch" href="/assets/js/5.ef7e662b.js"><link rel="prefetch" href="/assets/js/50.9d7b0ec8.js"><link rel="prefetch" href="/assets/js/51.67bccbad.js"><link rel="prefetch" href="/assets/js/52.0af555f2.js"><link rel="prefetch" href="/assets/js/53.92bf10ec.js"><link rel="prefetch" href="/assets/js/54.8dd03447.js"><link rel="prefetch" href="/assets/js/55.abfe1cc8.js"><link rel="prefetch" href="/assets/js/56.1c29c6a5.js"><link rel="prefetch" href="/assets/js/57.eefb1274.js"><link rel="prefetch" href="/assets/js/58.c3347bfb.js"><link rel="prefetch" href="/assets/js/59.5161f7d5.js"><link rel="prefetch" href="/assets/js/6.79d77de7.js"><link rel="prefetch" href="/assets/js/60.46020c7a.js"><link rel="prefetch" href="/assets/js/61.e2be29db.js"><link rel="prefetch" href="/assets/js/62.b153fccf.js"><link rel="prefetch" href="/assets/js/63.e01a855d.js"><link rel="prefetch" href="/assets/js/64.73a72aac.js"><link rel="prefetch" href="/assets/js/66.0a1b879d.js"><link rel="prefetch" href="/assets/js/67.6f7ac0ce.js"><link rel="prefetch" href="/assets/js/68.5bb317ba.js"><link rel="prefetch" href="/assets/js/69.e7c68577.js"><link rel="prefetch" href="/assets/js/7.0e6ba80a.js"><link rel="prefetch" href="/assets/js/70.eff372cf.js"><link rel="prefetch" href="/assets/js/71.5d5a96af.js"><link rel="prefetch" href="/assets/js/72.2c7a90f6.js"><link rel="prefetch" href="/assets/js/73.f5b5d0eb.js"><link rel="prefetch" href="/assets/js/74.2bf19254.js"><link rel="prefetch" href="/assets/js/75.a7043781.js"><link rel="prefetch" href="/assets/js/8.bb143dfb.js"><link rel="prefetch" href="/assets/js/9.d5dbe427.js">
    <link rel="stylesheet" href="/assets/css/0.styles.91fb4f46.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/android/" class="nav-link">Android</a></li><li class="dropdown-item"><!----> <a href="/web/" class="nav-link">Web</a></li><li class="dropdown-item"><!----> <a href="/hybrid/" class="nav-link">Hybrid</a></li><li class="dropdown-item"><!----> <a href="/artificial/" class="nav-link">人工智能</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link router-link-exact-active router-link-active">Vue</a></li></ul></div></div><div class="nav-item"><a href="/ide/" class="nav-link">工具</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/wolveq/wolveq.github.io.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/android/" class="nav-link">Android</a></li><li class="dropdown-item"><!----> <a href="/web/" class="nav-link">Web</a></li><li class="dropdown-item"><!----> <a href="/hybrid/" class="nav-link">Hybrid</a></li><li class="dropdown-item"><!----> <a href="/artificial/" class="nav-link">人工智能</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link router-link-exact-active router-link-active">Vue</a></li></ul></div></div><div class="nav-item"><a href="/ide/" class="nav-link">工具</a></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://github.com/wolveq/wolveq.github.io.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vue/" class="active sidebar-link">vue基本知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/#一、vue的优点是什么？" class="sidebar-link">一、vue的优点是什么？</a></li><li class="sidebar-sub-header"><a href="/vue/#二、与react的区别" class="sidebar-link">二、与React的区别?</a></li><li class="sidebar-sub-header"><a href="/vue/#三、生命周期" class="sidebar-link">三、生命周期</a></li><li class="sidebar-sub-header"><a href="/vue/#四、vue实现数据双向绑定的原理" class="sidebar-link">四、Vue实现数据双向绑定的原理</a></li><li class="sidebar-sub-header"><a href="/vue/#五、对keep-alive-的了解？" class="sidebar-link">五、对keep-alive 的了解？</a></li><li class="sidebar-sub-header"><a href="/vue/#六、vue路由的钩子函数" class="sidebar-link">六、vue路由的钩子函数</a></li><li class="sidebar-sub-header"><a href="/vue/#七、vuex有哪几种属性？" class="sidebar-link">七、vuex有哪几种属性？</a></li><li class="sidebar-sub-header"><a href="/vue/#八、常记知识" class="sidebar-link">八、常记知识</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue基本知识点"><a href="#vue基本知识点" aria-hidden="true" class="header-anchor">#</a> vue基本知识点</h1> <h2 id="一、vue的优点是什么？"><a href="#一、vue的优点是什么？" aria-hidden="true" class="header-anchor">#</a> 一、vue的优点是什么？</h2> <ol><li><p><strong>低耦合</strong>。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时
候Model可以不变，当Model变化的时候View也可以不变。</p></li> <li><p><strong>可重用性</strong>。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p></li> <li><p><strong>独立开发</strong>。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</p></li> <li><p><strong>可测试</strong>。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。
</p></li></ol> <h2 id="二、与react的区别"><a href="#二、与react的区别" aria-hidden="true" class="header-anchor">#</a> 二、与React的区别?</h2> <ul><li>相同点：
<br>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都</li></ul> <p>需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化</p> <p>地去处理需求；都不内置列数Ajax，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。</p> <ul><li>不同点：
<br>React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，</li></ul> <p>快捷地操作Virtual DOM。</p> <h2 id="三、生命周期"><a href="#三、生命周期" aria-hidden="true" class="header-anchor">#</a> 三、生命周期</h2> <ol><li><p>什么是vue生命周期？
<br>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染
、销毁等一系列过程，称之为 Vue 的生命周期。</p></li> <li><p>vue生命周期的作用是什么？
<br>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p></li> <li><p>vue生命周期总共有几个阶段？
<br>答：它可以总共分为<strong>8个阶段</strong>：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p></li> <li><p>第一次页面加载会触发哪几个钩子？
<br>答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。</p></li></ol> <p>生命周期钩子的一些使用方法：</p> <ul><li>beforecreate : 可以在这加个loading事件，在加载实例时触发</li> <li>created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用</li> <li>mounted : 挂载元素，获取到DOM节点</li> <li>updated : 如果对数据统一处理，在这里写上相应函数</li> <li>beforeDestroy : 可以做一个确认停止事件的确认框</li> <li>nextTick : 更新数据后立即操作dom</li></ul> <ol start="5"><li>DOM 渲染在 哪个周期中就已经完成？
<br>答：DOM 渲染在 <strong>mounted</strong> 中就已经完成了。</li></ol> <h2 id="四、vue实现数据双向绑定的原理"><a href="#四、vue实现数据双向绑定的原理" aria-hidden="true" class="header-anchor">#</a> 四、Vue实现数据双向绑定的原理</h2> <p>vue实现数据双向绑定主要是：采用<strong>数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter</strong>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p> <p>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 {{}}），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p> <p><strong>js实现简单的双向绑定</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>body<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;txt&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">&quot;show&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;text/javascript&quot;</span><span class="token operator">&gt;</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'txt'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">get</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> obj
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function-variable function">set</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">=</span> newValue
            document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> newValue
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'keyup'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        obj<span class="token punctuation">.</span>txt <span class="token operator">=</span> e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><h2 id="五、对keep-alive-的了解？"><a href="#五、对keep-alive-的了解？" aria-hidden="true" class="header-anchor">#</a> 五、对keep-alive 的了解？</h2> <p>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。</p> <p>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive include<span class="token operator">=</span><span class="token string">'include_components'</span> exclude<span class="token operator">=</span><span class="token string">'exclude_components'</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>component<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 该组件是否缓存取决于include和exclude属性 <span class="token operator">--</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
</code></pre></div><p>参数解释</p> <ul><li>include - 字符串或正则表达式，只有名称匹配的组件会被缓存</li> <li>exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存</li> <li>include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;
&lt;keep-alive include=&quot;a,b&quot;&gt;
  &lt;component&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;
&lt;keep-alive :include=&quot;/a|b/&quot;&gt;
  &lt;component&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;
&lt;keep-alive :include=&quot;['a', 'b']&quot;&gt;
  &lt;component&gt;&lt;/component&gt;
&lt;/keep-alive&gt;

</code></pre></div><h2 id="六、vue路由的钩子函数"><a href="#六、vue路由的钩子函数" aria-hidden="true" class="header-anchor">#</a> 六、vue路由的钩子函数</h2> <p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p> <ul><li>beforeEach主要有3个参数to，from，next：</li> <li>to：route即将进入的目标路由对象，</li> <li>from：route当前导航正要离开的路由</li> <li>next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</li></ul> <h2 id="七、vuex有哪几种属性？"><a href="#七、vuex有哪几种属性？" aria-hidden="true" class="header-anchor">#</a> 七、vuex有哪几种属性？</h2> <p>（1）vuex有哪几种属性？
只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。</p> <p>（2）vuex是什么？怎么使用？哪种功能场景使用它？</p> <p>vue框架中状态管理。在main.js引入store，注入。新建一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车</p> <h2 id="八、常记知识"><a href="#八、常记知识" aria-hidden="true" class="header-anchor">#</a> 八、常记知识</h2> <ol><li><p>css只在当前组件起作用
<br>答：在style标签中写入scoped即可 例如：</p><style scoped="scoped"></style><p></p></li> <li><p>v-if 和 v-show 区别
<br>答：v-if按照条件是否渲染，v-show是display的block或none；</p> <p>所以:
v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；
v-show 则适用于需要非常频繁切换条件的场景。</p></li> <li><p>route和router的区别
<br>答：route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p></li> <li><p>vue.js的两个核心是什么？
<br>答：数据驱动、组件系统</p></li> <li><p>vue常用的修饰符？
<br>答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p></li> <li><p>v-on可以绑定多个方法吗？
<br>答：可以</p></li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>onInput<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@focus</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>onFocus<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@blur</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>onBlur<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><ol start="7"><li><p>vue中 key 值的作用？
<br>答：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p> <p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，</p> <p>而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。</p></li> <li><p>怎么定义 vue-router 的动态路由? 怎么获取传过来的值
<br>答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。</p></li> <li><p>vue等单页面应用及其优缺点
<br>答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。</p> <p>缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p></li> <li><p>为什么避免 v-if 和 v-for 用在一起
<br>答：当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在  v-if 为否的时候运算 v-for。</p></li> <li><p>VNode是什么？虚拟 DOM是什么？
<br>答：Vue在 页面上渲染的节点，及其子节点称为“虚拟节点 (Virtual Node)”，简写为“VNode”。“虚拟 DOM”是由 Vue 组件树建立起来的整个 VNode 树的称呼。</p></li> <li><p>active-class是哪个组件的属性？
<br>答：vue-router模块的router-link组件。</p></li> <li><p>为什么vue中data必须是一个函数？
<br>答：对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p></li> <li><p>vue-loader是什么？使用它的用途有哪些？
<br>答：解析.vue文件的一个加载器，跟template/js/style转换成js模块。</p></li> <li><p>prop验证默认值
<br>答：避免不必要的错误，让父组件给子组件传值得时候，更加准确</p></li></ol> <div class="language-js extra-class"><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
	visible<span class="token punctuation">:</span> <span class="token punctuation">{</span>
		<span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
		type<span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>
		required<span class="token punctuation">:</span> <span class="token boolean">true</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="16"><li><p>vue路由传参数
1.使用query方法传入的参数使用this.$route.query接受</p> <p>2.使用params方式传入的参数使用this.$route.params接受</p></li> <li><p>v-for与v-if的优先级
<br>答：v-for优先级高于v-if</p></li> <li><p>axios的特点有哪些？
<br>答：1、axios是一个基于promise的HTTP库，支持promise的所有API；</p> <p>2、它可以拦截请求和响应；</p> <p>3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换为json类型的数据；</p> <p>4、它安全性更高，客户端支持防御XSRF；</p></li> <li><p>$route和$router的区别？
<br>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</p> <p>$router是'路由实例'对象包括了路由的跳转方法，钩子函数等。</p></li> <li><p>页面刷新vuex被清空解决办法？
<br>1.localStorage 存储到本地再回去</p> <p>2.重新获取接口获取数据</p></li> <li><p>vue中data的属性可以和methods中的方法同名吗？为什么？
<br>不能，会报错。</p></li> <li><p>怎么给vue定义全局的方法？</p> <ol><li>通过prototype，这个非常方便。Vue.prototype[method]=method;</li> <li>通过插件Vue.use(plugin)；</li> <li>通过mixin，Vue.mixin(mixins);</li></ol></li> <li><p>keep-alive的生命周?</p></li></ol> <ul><li>activated： 页面第一次进入的时候，钩子触发的顺序是created-&gt;mounted-&gt;activated</li> <li>deactivated: 页面退出的时候会触发deactivated，当再次前进或者后退的时候只触发activated</li></ul> <ol start="24"><li><p>v-once的使用场景有哪些？
<br>单独触发</p></li> <li><p>说说vue与ap交互的方法？
<br>1.app定义一个方法传给我们，
2.根据方法调用</p></li> <li><p>vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？
<br>答：肯定要，一方面是绑定多次，另一方面是函数没释放会内存溢出</p></li> <li><p>vue组件会在什么时候下被销毁？
<br>答：没有使用keep-alive时的路由切换。</p></li> <li><p>vue渲染大量数据时性能优化？
<br>答：可以使用虚拟滚动的组件：参考使用这个插件<a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener noreferrer">https://github.com/Akryum/vue-virtual-scroller<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>你有使用过JSX吗？说说你对JSX的理解?
<br>答：jsx不是一门新的语言，是一种新的语法糖。让我们在js中可以编写像html一样的代码。
允许XML语法直接加入到JavaScript代码中，让你能够高效的通过代码而不是模板来定义界面</p></li> <li><p>说说组件的命名规范?</p></li></ol> <p>1.kebab-case（短横线分隔命名），引用时必须也采用kebab-case；
<br>2.PascalCase（首字母大写命名），引用时既可以采用PascalCase也可以使用kebab-case；
但在DOM中使用只有kebab-case是有效的</p> <ol start="31"><li><p><code>&lt;template&gt;&lt;/template&gt;</code>有什么用？
<br>答：当做一个不可见的包裹元素，减少不必要的DOM元素，整个结构会更加清晰。</p></li> <li><p>组件中写name选项有什么作用？</p></li></ol> <ul><li>项目使用keep-alive时，可搭配组件name进行缓存过滤</li> <li>DOM做递归组件时需要调用自身name</li> <li>vue-devtools调试工具里显示的组见名称是由vue中组件name决定的</li></ul> <ol start="33"><li>动态组件？</li></ol> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>componentId<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>$options.components.child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="34"><li>prop验证的type类型有哪几种？</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//七种</span>
props<span class="token punctuation">:</span><span class="token punctuation">{</span>
	title<span class="token punctuation">:</span>String<span class="token punctuation">,</span>
	likes<span class="token punctuation">:</span> Number<span class="token punctuation">,</span>
	isPublished<span class="token punctuation">:</span> Boolean<span class="token punctuation">,</span>
	commentIds<span class="token punctuation">:</span> Array<span class="token punctuation">,</span>
	author<span class="token punctuation">:</span> Object<span class="token punctuation">,</span>
	callback<span class="token punctuation">:</span> Function<span class="token punctuation">,</span>
	contactsPromise<span class="token punctuation">:</span> Promise
<span class="token punctuation">}</span>
</code></pre></div><ol start="35"><li>怎么缓存当前打开的路由组件，缓存后想更新当前组件怎么办呢？</li></ol> <p>可以在路由meta中加入参数, 对打开的路由进行keep-alive的判断, 通过钩子active等</p> <ol start="36"><li>说说你对vue组件的设计原则的理解?</li></ol> <ul><li>第一: 容错处理, 这个要做好, 极端场景要考虑到, 不能我传错了一个参数你就原地爆炸</li> <li>第二: 缺省值(默认值)要有, 一般把应用较多的设为缺省值</li> <li>第三: 颗粒化, 把组件拆分出来.</li> <li>第四: 一切皆可配置, 如有必要, 组件里面使用中文标点符号, 还是英文的标点符号, 都要考虑到</li> <li>第五: 场景化, 如一个dialog弹出, 还需要根据不同的状态封装成success, waring, 等</li> <li>第六: 有详细的文档/注释和变更历史, 能查到来龙去脉, 新版本加了什么功能是因为什么</li> <li>第七: 组件名称, 参数prop, emit, 名称设计要通俗易懂, 最好能做到代码即注释这种程度</li> <li>第八: 可拓展性, 前期可能不需要这个功能, 但是后期可能会用上, 要预留什么, 要注意什么, 心里要有逼数</li> <li>第九: 规范化,我这个input组件, 叫on-change, 我另外一个select组件叫change, 信不信老子捶死你</li> <li>第十: 分阶段: 不是什么都要一期开发完成看具体业务, 如果一个select, 我只是个简单的select功能, 什么multi老子这个版本压根不需要,  别TM瞎折腾! 给自己加戏</li></ul> <ol start="37"><li>vue如何优化首页的加载速度？</li></ol> <p>异步路由和异步加载，还有分屏加载， 按需加载， 延时加载图片, cdn,Nginx的zip压缩、缓存静态页面等</p> <ol start="38"><li>vue中是如何使用event对象的？</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div @click='handleClick($events)'&gt;&lt;/div&gt;
</code></pre></div><ol start="39"><li>vue首页白屏是什么问题引起的？如何解决呢？</li></ol> <p>路由没配baseUrl。
在config文件夹中找到index.js打开把assetsPublicPath: '/'改成assetsPublicPath: './'，再次执行 npm run build 就可以了。</p> <ol start="40"><li>说说你对单向数据流和双向数据流的理解 ?</li></ol> <ul><li><p>单向数据流：所有状态的改变可记录、可跟踪，源头易追溯；所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性；一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data)；如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。</p></li> <li><p>双向数据流：无论数据改变，或是用户操作，都能带来互相的变动，自动更新。</p></li></ul> <ol start="41"><li><p>说说你对v-clock和v-pre指令的理解?</p> <ul><li>v-cloak指令只是在标签中加入一个v-cloak自定义属性，在HTML还编译完成之后该属性会被删除。</li> <li>v-pre可以用来阻止预编译，有v-pre指令的标签内部的内容不会被编译，会原样输出。</li></ul></li> <li><p>写出你知道的表单修饰符和事件修饰符?</p></li></ol> <ul><li>事件修饰符.stop, .prevent, .capture, .self, .once, .passive</li> <li>表单修饰符.number, .lazy, .trim</li></ul> <ol start="43"><li>如何解决vue打包vendor过大的问题？</li></ol> <ul><li>在webpack.base.conf.js新增externals配置，表示不需要打包的文件，然后在index.html中通过CDN引入</li></ul> <div class="language- extra-class"><pre class="language-text"><code>externals: {
    &quot;vue&quot;: &quot;Vue&quot;,
    &quot;vue-router&quot;: &quot;VueRouter&quot;,
    &quot;vuex&quot;: &quot;Vuex&quot;,
    &quot;element-ui&quot;: &quot;ELEMENT&quot;,
    &quot;BMap&quot;: &quot;BMap&quot;
  }
</code></pre></div><ul><li>使用路由懒加载</li></ul> <ol start="44"><li>$nextTick有什么作用？</li></ol> <p>处理数据动态变化后，dom还未及时更新的问题。nexttick就可以获取到数据更新后最新的dom变化</p> <div class="language- extra-class"><pre class="language-text"><code>// e.g
// do something
console.log(this.$refs.message) // old dom

this.$nextTick()
  .then(() =&gt; {
    console.log(this.$refs.message) // new dom
  })

</code></pre></div><ol start="45"><li>vue-router怎么重定向页面？</li></ol> <p>路由中配置redirect属性</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span> redirect<span class="token punctuation">:</span> <span class="token string">'/404'</span><span class="token punctuation">,</span> hidden<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
</code></pre></div><ol start="46"><li>vue-router有哪几种导航钩子（ 导航守卫 ）？</li></ol> <p>3种。 全局的、组件的、单个路由独享的</p> <ol start="47"><li>切换到新路由时，页面要滚动到顶部或保持原先的滚动位置怎么做呢？</li></ol> <div class="language- extra-class"><pre class="language-text"><code>//滚动到顶部：在new Router()的时候，配置
scrollBehavior(to, from, savedPosition) {
  return { x: 0, y: 0 }
}
</code></pre></div><ol start="48"><li>路由元信息</li></ol> <div class="language- extra-class"><pre class="language-text"><code>$route.matched
</code></pre></div><ol start="49"><li>vuex中actions和mutations有什么区别？</li></ol> <p>actions可以异步，mutations不可以;</p> <p>mutations可以直接修改state，但只能包含同步操作，同时，只能在actions中通过提交commit调用
actions是用来触发mutations的，它无法直接改变state，它可以包含异步操作，它只能通过store.dispatch触发</p> <ol start="50"><li>页面刷新后vuex的state数据丢失怎么解决？</li></ol> <p>就是放在localStorage 或者就是sessionStorage ，或者借用辅助插vuex-persistedstate</p> <ol start="51"><li>在循环里对每个input验证怎么做呢？</li></ol> <p>model 绑定表单数据 通过prop 取表单数值，根据rule取form-item rules 或则rules[prop]校验</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f08b4700.js" defer></script><script src="/assets/js/2.4e7c4cdc.js" defer></script><script src="/assets/js/65.12532cb0.js" defer></script>
  </body>
</html>
