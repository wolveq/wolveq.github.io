<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue入门到精通 | Learn</title>
    <meta name="description" content="我的个人网站">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.b5fee74e.css" as="style"><link rel="preload" href="/assets/js/app.04e102c0.js" as="script"><link rel="preload" href="/assets/js/2.7da4a511.js" as="script"><link rel="preload" href="/assets/js/7.780e078c.js" as="script"><link rel="prefetch" href="/assets/js/10.85f1b5b3.js"><link rel="prefetch" href="/assets/js/3.cf7a67d5.js"><link rel="prefetch" href="/assets/js/4.ce8cbe84.js"><link rel="prefetch" href="/assets/js/5.b47cf8bb.js"><link rel="prefetch" href="/assets/js/6.3be5a4a3.js"><link rel="prefetch" href="/assets/js/8.a262f893.js"><link rel="prefetch" href="/assets/js/9.5189dcd3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b5fee74e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Learn</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">home</a></div><div class="nav-item"><a href="/posts/" class="nav-link">Posts</a></div><div class="nav-item"><a href="/about/" class="nav-link router-link-active">About</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">home</a></div><div class="nav-item"><a href="/posts/" class="nav-link">Posts</a></div><div class="nav-item"><a href="/about/" class="nav-link router-link-active">About</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/posts/typescript.html" class="sidebar-link">vue + typescript结合</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>本文以前端面试官的角度出发，对 Vue 框架中一些重要的特性、框架的原理以问题的形式进行整理汇总，意在帮助作者及读者自测下 Vue 掌握的程度。</p> <h4 id="_1、说说你对-spa-单页面的理解，它的优缺点分别是什么？"><a href="#_1、说说你对-spa-单页面的理解，它的优缺点分别是什么？" aria-hidden="true" class="header-anchor">#</a> 1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h4> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p> <h5 id="优点："><a href="#优点：" aria-hidden="true" class="header-anchor">#</a> 优点：</h5> <ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ol> <h5 id="缺点："><a href="#缺点：" aria-hidden="true" class="header-anchor">#</a> 缺点：</h5> <ol><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ol> <h4 id="_2、v-show-与-v-if-有什么区别？"><a href="#_2、v-show-与-v-if-有什么区别？" aria-hidden="true" class="header-anchor">#</a> 2、v-show 与 v-if 有什么区别？</h4> <p>v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p> <p>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p> <p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p> <h4 id="_3、class-与-style-如何动态绑定？"><a href="#_3、class-与-style-如何动态绑定？" aria-hidden="true" class="header-anchor">#</a> 3、Class 与 Style 如何动态绑定？</h4> <ol><li>Class 可以通过对象语法和数组语法进行动态绑定：</li></ol> <ul><li>对象语法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div :class=&quot;{ active: isActive, 'text-danger': hasError }&quot;&gt;&lt;/div&gt;

data: {
  isActive: true,
  hasError: false
}
</code></pre></div><ul><li>数组语法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div :class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;

data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
</code></pre></div><ol start="2"><li>Style 也可以通过对象语法和数组语法进行动态绑定：</li></ol> <ul><li>对象语法：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div :style=&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;&gt;&lt;/div&gt;

data: {
  activeColor: 'red',
  fontSize: 30
}
</code></pre></div><p>数组语法：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div :style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;

data: {
  styleColor: {
     color: 'red'
   },
  styleSize:{
     fontSize:'23px'
  }
}
</code></pre></div><h4 id="_4、怎样理解-vue-的单向数据流？"><a href="#_4、怎样理解-vue-的单向数据流？" aria-hidden="true" class="header-anchor">#</a> 4、怎样理解 Vue 的单向数据流？</h4> <p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong> ：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p> <p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 <strong>$emit</strong>派发一个自定义事件，父组件接收到后，由父组件修改。</p> <ul><li>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>props: ['initialCounter'],
data: function () {
  return {
    counter: this.initialCounter
  }
}
</code></pre></div><ul><li>这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li></ul> <div class="language- extra-class"><pre class="language-text"><code>props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre></div><h4 id="_5、computed-和-watch-的区别和运用的场景？"><a href="#_5、computed-和-watch-的区别和运用的场景？" aria-hidden="true" class="header-anchor">#</a> 5、computed 和 watch 的区别和运用的场景？</h4> <p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p> <p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p> <h5 id="运用场景："><a href="#运用场景：" aria-hidden="true" class="header-anchor">#</a> 运用场景：</h5> <ul><li><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p></li> <li><p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></li></ul> <h4 id="_6、直接给一个数组项赋值，vue-能检测到变化吗？"><a href="#_6、直接给一个数组项赋值，vue-能检测到变化吗？" aria-hidden="true" class="header-anchor">#</a> 6、直接给一个数组项赋值，Vue 能检测到变化吗？</h4> <p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动</p> <h4 id="_7、谈谈你对-vue-生命周期的理解？"><a href="#_7、谈谈你对-vue-生命周期的理解？" aria-hidden="true" class="header-anchor">#</a> 7、谈谈你对 Vue 生命周期的理解？</h4> <p>1、creating 状态--vue 实例被创建的过程
2、mounting 状态--挂到到真实的 DOM 节点
3、updating 状态--如果 data 中的数据改变就会触发对应组件的重新渲染
4、destroying 状态--实例销毁</p> <table><thead><tr><th>方法名</th> <th>状态</th> <th>含义</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td>creating 状态</td> <td>实例创建之前调用</td></tr> <tr><td>created</td> <td>creating 状态</td> <td>实例创建成功，此时 data 中的数据显示出来了</td></tr> <tr><td>beforeMount</td> <td>mounting 状态</td> <td>数据中的 data 在模版中先占一个位置</td></tr> <tr><td>mounted</td> <td>mounting 状态</td> <td>模版中的 data 数据直接显示出来了</td></tr> <tr><td>beforeUpdate</td> <td>updating 状态</td> <td>当 data 数据发生变化调用，发生在虚拟 DOM 重新渲染和打补丁之前</td></tr> <tr><td>updated</td> <td>updating 状态</td> <td>数据更改导致的虚拟 DOM 重新渲染和打补丁</td></tr> <tr><td>beforeDestroy</td> <td>destroying 状态</td> <td>在 vue 实例销毁之前调用，此时实例任然可用</td></tr> <tr><td>destroyed</td> <td>destroying 状态</td> <td>在 vue 实例销毁之后调用</td></tr></tbody></table> <h4 id="_8、在哪个生命周期内调用异步请求？"><a href="#_8、在哪个生命周期内调用异步请求？" aria-hidden="true" class="header-anchor">#</a> 8、在哪个生命周期内调用异步请求？</h4> <p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p> <ol><li>能更快获取到服务端数据，减少页面 loading 时间；</li> <li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性</li></ol> <h4 id="_9、在什么阶段才能访问操作dom？"><a href="#_9、在什么阶段才能访问操作dom？" aria-hidden="true" class="header-anchor">#</a> 9、在什么阶段才能访问操作DOM？</h4> <p>mounted</p> <h4 id="_10、父组件可以监听到子组件的生命周期吗？"><a href="#_10、父组件可以监听到子组件的生命周期吗？" aria-hidden="true" class="header-anchor">#</a> 10、父组件可以监听到子组件的生命周期吗？</h4> <p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p> <div class="language- extra-class"><pre class="language-text"><code>// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;
    
// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}

</code></pre></div><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ... 
</code></pre></div><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p> <h4 id="_11、谈谈你对-keep-alive-的了解？"><a href="#_11、谈谈你对-keep-alive-的了解？" aria-hidden="true" class="header-anchor">#</a> 11、谈谈你对 keep-alive 的了解？</h4> <p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p> <ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li> <li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li> <li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul> <h4 id="_12、组件中-data-为什么是一个函数？"><a href="#_12、组件中-data-为什么是一个函数？" aria-hidden="true" class="header-anchor">#</a> 12、组件中 data 为什么是一个函数？</h4> <p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p> <div class="language- extra-class"><pre class="language-text"><code>// data
data() {
  return {
	message: &quot;子组件&quot;,
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '&lt;App/&gt;',
  components: {App}
})

</code></pre></div><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p> <h4 id="_13、v-model-的原理？"><a href="#_13、v-model-的原理？" aria-hidden="true" class="header-anchor">#</a> 13、v-model 的原理？</h4> <p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul> <p>以 input 表单元素为例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;input v-model='something'&gt;
    
相当于

&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre></div><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>父组件：
&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;

子组件：
&lt;div&gt;{{value}}&lt;/div&gt;

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},
</code></pre></div><h4 id="_14、vue-组件间通信有哪几种方式？"><a href="#_14、vue-组件间通信有哪几种方式？" aria-hidden="true" class="header-anchor">#</a> 14、Vue 组件间通信有哪几种方式？</h4> <p>3类通信：父子组件通信、隔代组件通信、兄弟组件通信
（1）props / $emit 适用 父子组件通信
（2）ref 与 $parent / $children 适用 父子组件通信
（3）EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信
（4）$attrs/$listeners 适用于 隔代组件通信
（5）provide / inject 适用于 隔代组件通信
（6）Vuex 适用于 父子、隔代、兄弟组件通信</p> <h4 id="_15、你使用过-vuex-吗？"><a href="#_15、你使用过-vuex-吗？" aria-hidden="true" class="header-anchor">#</a> 15、你使用过 Vuex 吗？</h4> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p> <p>主要包括以下几个模块：</p> <ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li> <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li> <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul> <h4 id="_16、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#_16、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" aria-hidden="true" class="header-anchor">#</a> 16、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h4> <p>（1）hash 模式的实现原理</p> <p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：</p> <div class="language- extra-class"><pre class="language-text"><code>https://www.word.com#search
</code></pre></div><p>hash 路由模式的实现主要是基于下面几个特性：</p> <ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li> <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li> <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul> <p>（2）history 模式的实现原理</p> <p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
</code></pre></div><p>history 路由模式的实现主要基于存在下面几个特性：</p> <ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li> <li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li> <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul> <h4 id="_17、什么是-mvvm？"><a href="#_17、什么是-mvvm？" aria-hidden="true" class="header-anchor">#</a> 17、什么是 MVVM？</h4> <p>（1）View 层</p> <p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p> <p>（2）Model 层</p> <p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p> <p>（3）ViewModel 层</p> <h4 id="_18、vue-是如何实现数据双向绑定的？"><a href="#_18、vue-是如何实现数据双向绑定的？" aria-hidden="true" class="header-anchor">#</a> 18、Vue 是如何实现数据双向绑定的？</h4> <p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：
<img src="/images/55ffj6k34ddfg.png" alt="avatar"></p> <h4 id="_19、vue-中的-key-有什么作用？"><a href="#_19、vue-中的-key-有什么作用？" aria-hidden="true" class="header-anchor">#</a> 19、Vue 中的 key 有什么作用？</h4> <p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><div class="reading-progress top" data-v-7681808f><div class="progress" data-v-7681808f></div></div></div></div>
    <script src="/assets/js/app.04e102c0.js" defer></script><script src="/assets/js/2.7da4a511.js" defer></script><script src="/assets/js/7.780e078c.js" defer></script>
  </body>
</html>
